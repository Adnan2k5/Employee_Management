Why is testing considered an 'optimistic' verification technology?

 

You can use testing on any kind of software, whereas you can only run static analysis or proofs on small systems.



Any tests that fail may not actually matter from the user's perspective



The tests may all pass but the program may still be incorrect



Some tests may fail, but the program may be correct.


1 point
2.
Question 2
If a test fails, it could mean:

 

The program is incorrect



There is no problem



The test itself is incorrect


1 point
3.
Question 3
Suppose we have two systems A and B, and A is more rigorously tested than B.  Does System A better meet its quality goals than System B?

 

No



Yes


1 point
4.
Question 4
Unit test is used to test: (choose best answer)

 

Design of the software.



Implementation of the software.



User initial requirements.



All of the above.


1 point
5.
Question 5
'Service' is the system behavior as defined by the software requirements.

 

False



True


1 point
6.
Question 6
A latent error becomes an effective error when

 

the program reaches a state where the error manifests.



the error causes the program to return something unexpected to the user.



the user types it into the code



the program executes the line of code containing the latent error.



the program starts executing


1 point
7.
Question 7
Does a program terminating with an error always indicate a failure?

 

Yes



No


1 point
8.
Question 8
Adaptive cruise control software that continues to run in the presence of multiple hardware and service failures but regularly misjudges the distance between cars by a substantial amount is an example of a ______ system.

 

certainly reliable



certainly safe



certainly correct



certainly robust



certainly incorrect


1 point
9.
Question 9
Mutation testing is a _______ metric

 

gray-box



white-box



black-box


1 point
10.
Question 10
Which of the following are true about testing? Check all that apply.

 

It is difficult to do rigorously.



It can sometimes find errors that are not actively looked for, when (for example) a program crashes during execution of a test case.



It checks the whole system, including software that you didn't write.



It documents system behavior.



It can conclusively determine whether the software is correct.


1 point
11.
Question 11
Tasks that can be part of the Tear Down phase are (choose two answers):

 

Initialize test case values.



Remove data you added after testing is done.



Open connection for testing.



Close connection after testing is done.


1 point
12.
Question 12
In the JUnit test framework, we write test cases (choose the best answer):

 

inside the executed method and we annotate that this part is for testing.



inside the class to be tested we annotate that this part is for testing.



in a separate class, and for each method in the program we associated a test case(s) to test the correctness of the method.



All of the above.


1 point
13.
Question 13
Concurrent systems are quite difficult to test because (choose the best answer):

 

All of the above



to ensure that only one thread uses a variable at a time, Java 'synchronized' code can lead to deadlocks where each thread is blocked waiting for another thread.



the different potential interleavings of threads means that there are many more possible system states



the different potential interleavings of threads leads to 'race conditions' where the program may behave differently between executions


1 point
